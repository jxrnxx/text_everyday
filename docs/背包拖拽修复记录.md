# 背包拖拽功能修复记录

> 本文档记录了背包系统拖拽功能的问题排查和修复过程。

---

## 🐛 问题描述

### 1. 拖拽功能不工作
- **现象**: 无法拖拽物品到其他格子
- **根本原因**: 
  - `on-ui-DragStart` 等JSX属性在当前React-Panorama环境下工作正常
  - 但 `dragPanel` 对象在不同事件之间**不共享状态**
  - `handleDragDrop` 中读取 `dragPanel.itemIndex` 和 `dragPanel.storageType` 为 `undefined`

### 2. 图片预加载失效
- **现象**: 首次购买物品时背景图有0.5秒加载延迟
- **根本原因**: 
  - 预加载代码在模块级执行，但此时 `$.GetContextPanel()` 可能还未挂载
  - 预加载函数需要在组件 `useEffect` 中延迟执行

### 3. 拖拽预览位置错误
- **现象**: 拖拽预览显示在屏幕左上角，而不是跟随鼠标
- **原因**: 使用了 1x1 像素的隐形 `displayPanel`，导致无视觉反馈

---

## ✅ 解决方案

### 1. 使用 `useRef` 存储拖拽状态

在 `DefaultBackpackPanel` 组件中添加 `dragStateRef`：

```typescript
const dragStateRef = useRef<{
    itemIndex: number;
    storageType: 'public' | 'private';
    sourcePanel: Panel | null;
    displayPanel: any;
    dragComplete: boolean;
} | null>(null);
```

### 2. 修改拖拽事件处理器

#### handleDragStart
```typescript
// 存储拖拽信息到 ref（确保跨事件共享）
dragStateRef.current = {
    itemIndex: index,
    storageType: storageType,
    sourcePanel: panel,
    displayPanel: displayPanel,
    dragComplete: false,
};

// 同时存储到 dragPanel（Panorama 需要）
dragPanel.itemIndex = index;
dragPanel.storageType = storageType;
// ...
```

#### handleDragDrop
```typescript
// 从 ref 读取拖拽状态（更可靠）
const dragState = dragStateRef.current;
const sourceIndex = dragState?.itemIndex ?? dragPanel.itemIndex;
const sourceType = dragState?.storageType ?? dragPanel.storageType;

// 执行交换逻辑
if (sourceIndex !== index || sourceType !== storageType) {
    dragPanel.b_dragComplete = true;
    if (dragState) dragState.dragComplete = true;
    // ...
}
```

#### handleDragEnd
```typescript
// 从 ref 读取拖拽状态
const dragState = dragStateRef.current;

// 清理 displayPanel
if (dragState?.displayPanel) {
    dragState.displayPanel.DeleteAsync(0);
}

// 恢复透明度
if (dragState?.sourcePanel) {
    dragState.sourcePanel.style.opacity = '1';
}

// 清空 ref
dragStateRef.current = null;
```

### 3. 创建可见的拖拽预览

```typescript
// 创建可见的拖拽预览（48x48px）
const displayPanel: any = $.CreatePanel('Panel', $.GetContextPanel(), 'dragImage');
displayPanel.style.width = '48px';
displayPanel.style.height = '48px';
displayPanel.style.borderRadius = '4px';

// 设置背景
if (rarityBg) {
    displayPanel.style.backgroundImage = `url("${rarityBg}")`;
    displayPanel.style.backgroundSize = '100% 100%';
} else {
    displayPanel.style.backgroundColor = '#333333aa';
}

// 添加物品图标
if (itemConfig && itemConfig.icon) {
    const iconImage: any = $.CreatePanel('Image', displayPanel, 'dragIcon');
    iconImage.SetImage(itemConfig.icon);
    iconImage.style.width = '44px';
    iconImage.style.height = '44px';
    iconImage.style.horizontalAlign = 'center';
    iconImage.style.verticalAlign = 'center';
}
```

### 4. 修复图片预加载

将预加载从模块级移到组件的 `useEffect` 中：

```typescript
// 初始化物品数组 + 预加载图片
useEffect(() => {
    // ... 初始化数组 ...

    // 延迟预加载图片，确保面板已挂载
    $.Schedule(0.5, () => {
        const contextPanel = $.GetContextPanel();
        if (contextPanel) {
            preloadImages(contextPanel);
        } else {
            $.Msg('[Backpack] 无法获取 contextPanel，跳过预加载');
        }
    });
}, []);
```

---

## 📊 修改文件

| 文件 | 修改内容 |
|------|----------|
| [DefaultBackpackPanel.tsx](file:///d:/text_everyday/content/panorama/src/hud/DefaultBackpackPanel.tsx) | 添加 `dragStateRef`，修改拖拽事件处理器，优化预加载 |

---

## 🧪 测试验证

### 拖拽功能测试
- [x] 拖拽物品到另一个格子，成功交换位置
- [x] 拖拽预览图标跟随鼠标移动
- [x] 控制台有正确的拖拽日志：
  ```
  [Backpack] 拖拽开始: private[3]
  [Backpack] 拖拽物品: item_upgrade_stone_2
  [Backpack] 拖拽已开始
  [Backpack] 拖拽放下触发: public[8]
  [Backpack] 源位置: private[3]
  [Backpack] 交换物品: private[3] -> public[8]
  [Backpack] 拖拽结束
  [Backpack] 拖拽完成
  ```

### 预加载测试
- [ ] 控制台有 `[Backpack] preloadImages 被调用` 日志
- [ ] 控制台有 `[Backpack] 图片预加载完成` 日志
- [ ] 首次购买物品时背景图立即显示（无延迟）

---

## 💡 技术要点

### 1. React-Panorama 拖拽事件
- 使用 JSX 属性 `on-ui-DragStart`, `on-ui-DragDrop`, `on-ui-DragEnd`
- **不要**使用 `$.RegisterEventHandler`，React 会自动处理
- 确保 `draggable={true}` 设置在可拖拽的 Panel 上

### 2. 跨事件状态共享
- Panorama 的 `dragPanel` 对象在不同事件之间**可能不同**
- 使用 React 的 `useRef` 来存储跨事件的状态
- 同时保存到 `dragPanel` 作为备份（双保险）

### 3. Panorama 特效预加载
- 必须在面板挂载后才能创建预加载面板
- 使用 `$.Schedule` 延迟执行
- 创建 1x1 像素的隐形 Image 面板进行预加载
- 0.5秒后删除预加载面板

---

## 🔍 问题排查思路

1. **拖拽事件不触发**：
   - 检查 JSX 属性是否正确
   - 检查 `draggable={true}` 是否设置
   - 检查子元素是否有 `hittest={false}`

2. **拖拽状态丢失**：
   - 使用 `$.Msg` 打印 `dragPanel` 的属性
   - 检查不同事件中 `dragPanel` 是否是同一个对象
   - 使用 React `useRef` 存储状态

3. **预加载不生效**：
   - 检查 `$.GetContextPanel()` 是否返回 null
   - 检查预加载代码执行时机（是否在组件挂载后）
   - 添加调试日志确认预加载函数是否被调用

---

## 📝 总结

通过使用 React `useRef` 来存储拖拽状态，解决了 Panorama `dragPanel` 对象跨事件不共享的问题。同时优化了拖拽预览的视觉效果和图片预加载逻辑。

**关键点**：
- 状态管理：`useRef` 跨事件共享 + `dragPanel` 备份
- 视觉反馈：48x48px 可见预览 + 物品图标
- 预加载时机：组件 `useEffect` + `$.Schedule` 延迟
